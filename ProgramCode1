/*
 * Orbit-360 Robot Control System - Main Program File
 * 
 * This is the main control program for the Orbit-360 maze-solving robot.
 * It implements a comprehensive system for autonomous maze exploration and mapping
 * in an unkown environment using various sensors and advanced algorithms 
 * including frontier-based exploration, SLAM and A* pathfinding.
 *
 * Physical Components:
 * - Arduino Nano 33 BLE
 * - 2x HC-SR04 Ultrasonic Sensors (Front Left/Right)
 * - 2x Sharp GP2Y0E02B IR Sensors (Side Left/Right)
 * - 7-pixel RGBW NeoPixel Jewel LED
 * - 2x DC Motors with Encoders
 *
 * Logical Sequence:
 * 1. Initialisation: Set up hardware components and initialise data structures.
 * 2. Exploration: The robot explores the maze using a frontier-based approach.
 * 3. Mapping: Simultaneous Localisation and Mapping (SLAM) is used to build a map.
 * 4. Path Planning: A* algorithm plans optimal paths to unexplored areas.
 * 5. Navigation: PID controllers guide the robot along planned paths.
 * 6. Completion: The robot returns to its starting position once exploration is complete.
 *
 * Core classes and structures:
 * - Sensors Class: Manages ultrasonic and IR sensors. Uses median filtering to reduce noise.
 *   Stores readings in a SensorReadings struct.
 * - Encoder Class: Handles wheel encoders for odometry. Uses interrupt-based tick counting
 *   for precise position tracking.
 * - Motors Class: Controls DC motors. Implements a speed calibration table (2D array) based on 
 *   test data for accurate speed control and conversion between PWM values and speeds.
 * - PIDController Class: Implements a generic PID controller for various control tasks.
 * - Particle Class: Represents a single particle in the particle filter used for localisation.
 * - SLAM Class: Estimates robot position using enccoder data, sensor data and a particle filter then
 * - implements SLAM (Simultaneous Localisation and Mapping). Uses a 1D vector to
 *   represent a 2D occupancy grid for efficient memory usage.
 * - PathPlanner Class: Implements A* pathfinding algorithm. Uses a priority queue for
 *   efficient node selection and a 2D vector for the closed list.
 * - Robot Class: Main control class that integrates all components. Implements a state
 *   machine for different robot behaviors and exploration strategies.
 * 
 * Note on Pose struct: The Pose struct is defined globally for easy access across
 * multiple classes.
 */


// ===== Include statements =====
#include <Adafruit_NeoPixel.h> // For controlling the NeoPixel LED
#include <ArduinoBLE.h> // For Bluetooth Low Energy functionality
#include <mbed.h> // Core mbed OS functionality for hardware control
#include "rtos.h" // Real-time operating system features for multitasking
#undef abs // Undefine abs to prevent conflicts with std::abs
#include <vector> // Dynamic arrays for storing data
#include <queue> // Priority queues for pathfinding algorithms
#include <unordered_set> // Hash sets for efficient lookups in algorithms
#include <algorithm> // Standard algorithms like sort, find, etc.
#include <cmath> // Mathematical functions like sin, cos, sqrt
#include <random> // Random number generation for particle filter
#include <limits> // Numeric limits for comparison in algorithms
#include <cstdint> // Fixed-width integer types for precise control
#include <atomic>
using namespace std::chrono_literals; // For using time literals like 100ms
using namespace rtos; // For using RTOS features
using namespace mbed;


// ===== Pin Definitions =====
#define MOTOR_DIR_R P0_4 // Right motor direction pin
#define MOTOR_DIR_L P0_5 // Left motor direction pin
#define MOTOR_PWM_R P0_27 // Right motor PWM control pin
#define MOTOR_PWM_L P1_2 // Left motor PWM control pin
#define MOTOR_ENCODER_R P1_11 // Right motor encoder pin
#define MOTOR_ENCODER_L P1_12 // Left motor encoder pin
#define ULTRA_LEFT_PIN P1_13 // Left ultrasonic sensor pin
#define ULTRA_RIGHT_PIN P0_23 // Right ultrasonic sensor pin
#define I2C_SDA P0_31 // I2C data line for sensor communication
#define I2C_SCL P0_2 // I2C clock line for sensor communication
#define LED A7 // NeoPixel LED data pin

// ===== Robot Physical Specifications =====
static constexpr float WHEEL_DIAMETER = 4.7f; // Wheel diameter in centimetres
static constexpr float WHEEL_WIDTH = 12.0f; // Wheel width in millimetres
static constexpr float WHEEL_TRACK = 130.0f; // Distance between wheels in millimetres
static constexpr float WHEEL_CIRCUMFERENCE = PI * WHEEL_DIAMETER; // Wheel circumference for distance calculations
static constexpr float TURN_CIRCLE_CIRCUMFERENCE = PI * WHEEL_TRACK; // Full rotation circumference
static constexpr float ROTATIONS_PER_360 = TURN_CIRCLE_CIRCUMFERENCE / WHEEL_CIRCUMFERENCE; // Rotations for 360Â°
static constexpr float ROBOT_WIDTH = 200.0f; // Robot width in millimetres
static constexpr float ROBOT_DIAMETER = 200.0f; // Robot diameter in millimetres
static constexpr float ROBOT_CIRCUMFERENCE = 628.319f; // Robot circumference in millimetres
static constexpr float ROBOT_AREA = 31415.9f; // Robot area in square millimetres

// ===== Sensor Constants =====
// Sensor positions relative to robot center (in millimetres)
static constexpr float ULTRASONIC_LEFT_X = -42.9f; // Left ultrasonic X offset
static constexpr float ULTRASONIC_LEFT_Y = 75.0999f; // Left ultrasonic Y offset
static constexpr float ULTRASONIC_RIGHT_X = 42.9f; // Right ultrasonic X offset
static constexpr float ULTRASONIC_RIGHT_Y = 75.0999f; // Right ultrasonic Y offset
static constexpr float IR_LEFT_X = -90.15f; // Left IR sensor X offset
static constexpr float IR_LEFT_Y = 2.113f; // Left IR sensor Y offset
static constexpr float IR_RIGHT_X = 90.15f; // Right IR sensor X offset
static constexpr float IR_RIGHT_Y = 2.113f; // Right IR sensor Y offset

// Sensor specifications
static constexpr int ULTRA_READINGS_COUNT = 50; // Number of ultrasonic readings for median filtering
static constexpr int IR_READINGS_COUNT = 40; // Number of IR readings for median filtering
static constexpr float IR_MIN_RANGE = 4.0f; // Minimum range for IR sensors in cm
static constexpr float IR_MAX_RANGE = 50.0f; // Maximum range for IR sensors in cm
static constexpr float ULTRA_MIN_RANGE = 2.0f; // Minimum range for ultrasonic sensors in cm
static constexpr float ULTRA_MAX_RANGE = 400.0f; // Maximum range for ultrasonic sensors in cm
static constexpr float IR_RESPONSE_TIME = 60000.0f; // IR sensor response time in microseconds
static constexpr float ULTRA_RESPONSE_TIME = 60000.0f; // Ultrasonic sensor response time in microseconds
static constexpr float SENSOR_NOISE = 0.1f; // Expected sensor noise factor for error modeling
static constexpr char I2C_MUX_ADDR = 0xEE; // I2C Mux address
static constexpr char I2C_SENSOR_ADDR = 0x80; // I2C Sensor address
static constexpr char I2C_SHIFT_REG = 0x35; // Register address for the shift bit
static constexpr char I2C_DISTANCE_REG =  0x5E; // Register address for distance measurement
static constexpr float SPEED_OF_SOUND = 343.0;
static constexpr const uint64_t ULTRA_TIMEOUT = 23200;

// ===== Motor and Encoder Constants =====
static constexpr int TICKS_PER_REV = 6; // Expected ticks per revolution
static constexpr float RIGHT_TICKS_PER_REV = 6.0f; // Measured average for right encoder
static constexpr float LEFT_TICKS_PER_REV = 6.0f; // Measured average for left encoder
static constexpr float PWM_FREQUENCY = 20000.0f; // PWM frequency in Hz
static constexpr uint32_t BRAKE_TIME = 100; // Brake time in milliseconds
static constexpr float GEAR_RATIO = 110.0f; // Gear ratio for motor control
static constexpr float RIGHT_TICKS_TO_CM =  (RIGHT_TICKS_PER_REV * GEAR_RATIO) / WHEEL_CIRCUMFERENCE; // Conversion factor for right encoder ticks to cm
static constexpr float LEFT_TICKS_TO_CM = (LEFT_TICKS_PER_REV * GEAR_RATIO) / WHEEL_CIRCUMFERENCE; // Conversion factor for left encoder ticks to cm

// ===== SLAM and Navigation Constants =====
static constexpr int GRID_SIZE = 24; // Size of the occupancy grid
static constexpr float MAZE_SIZE = 240.0f; // Size of the maze in cm
static constexpr float EXPLORATION_SPEED = 8.0f; // Exploration speed in cm/s
static constexpr float RETURN_SPEED = 10.0f; // Return speed in cm/s
static constexpr float TURN_SPEED = 8.0f; // Turn speed in rad/s
static constexpr float EXPLORATION_THRESHOLD = 0.9f; // 90% of the maze explored
static constexpr int MAX_STUCK_ATTEMPTS = 5; // Maximum attempts to resolve stuck situation
static constexpr float STUCK_DISTANCE_THRESHOLD = 3.0f; // Threshold for stuck detection in cm
static constexpr float STUCK_TIME_THRESHOLD = 5000.0f; // Time threshold for stuck detection in ms
static constexpr float ULTRA_SAFETY_MARGIN = 4.5f; // Minimum safe distance from obstacles in cm for the ultrasonic sensor
static constexpr float IR_SAFETY_MARGIN = 5.2; // Minimum safe distance from obstacles in cm for the IR sensor
static constexpr float CELL_SIZE = 10.0f; // Size of each grid cell in cm
static constexpr float OCCUPIED_THRESHOLD = 0.7f; // Threshold for considering a cell occupied
static constexpr float FREE_THRESHOLD = 0.3f; // Threshold for considering a cell free

// ===== LED Constants =====
static constexpr int NUM_PIXELS = 7; // Number of NeoPixel LEDs

// ===== Odometry Constants =====
static constexpr int PARTICLE_COUNT = 200 ; // Number of particles for particle filter
static constexpr float SPEED_FILTER_ALPHA = 0.7f; // Alpha value for speed filtering
static constexpr float MIN_SPEED_THRESHOLD = 0.5f; // Minimum speed threshold in cm/s



// ===== Pose Struct =====
/**
  Pose Struct
  Represents the robot's pose (position and orientation) in 2D space.
*/
struct Pose {
  float x;     // X-coordinate in centimetres
  float y;     // Y-coordinate in centimetres
  float theta; // Orientation in radians

  Pose(float x_ = 0.0f, float y_ = 0.0f, float theta_ = 0.0f)
      : x(x_), y(y_), theta(theta_) {}
};



// ===== Sensor Class =====
/**
 * Sensors Class
 * 
 * This class manages ultrasonic and IR distance sensors for the Orbit-360 robot.
 * It provides filtered distance measurements through median sampling to reduce noise.
 */
class Sensors {
private:
    // Hardware interfaces
    mbed::DigitalInOut leftUltrasonic;
    mbed::DigitalInOut rightUltrasonic;
    mbed::I2C i2c;
    mbed::Timer timer;

    /**
     * Calculates the median from an array of sensor readings for noise reduction.
     * 
     * @param readings Array of float values to process
     * @param size Size of the readings array
     * @return Median value from the array
     */
    float getMedianReading(float readings[], int size) {
        // Simple bubble sort for median calculation
        for (int i = 0; i < size - 1; i++) {
            for (int j = 0; j < size - i - 1; j++) {
                if (readings[j] > readings[j + 1]) {
                    float temp = readings[j];
                    readings[j] = readings[j + 1];
                    readings[j + 1] = temp;
                }
            }
        }
        return readings[size / 2];
    }

    /**
     * Validates a sensor reading based on its specified range.
     * 
     * @param reading The sensor reading to validate
     * @param minRange The minimum valid range for the sensor
     * @param maxRange The maximum valid range for the sensor
     * @return The validated reading, or -1 if out of range
     */
    float validateReading(float reading, float minRange, float maxRange) {
        if (reading >= minRange && reading <= maxRange) {
            return reading;
        }
        return -1;  // Invalid reading
    }

public:
    /**
     * Structure to hold all sensor readings.
     */
    struct SensorReadings {
        float leftUltrasonic;
        float rightUltrasonic;
        float leftIR;
        float rightIR;
    };

    /**
     * Constructor: Initialises all sensor hardware interfaces.
     */
    Sensors()
        : leftUltrasonic(ULTRA_LEFT_PIN),
          rightUltrasonic(ULTRA_RIGHT_PIN),
          i2c(I2C_SDA, I2C_SCL),
          timer() {}

    /**
     * Initialises sensors and starts the timer.
     */
    bool begin() {
        timer.start();
        i2c.frequency(100000);  // Set I2C frequency to 100kHz

        // Initialise ultrasonic sensors
        leftUltrasonic.output();
        rightUltrasonic.output();
        
        // Test I2C communication
        char test_cmd = 0x00;
        if (i2c.write(I2C_MUX_ADDR, &test_cmd, 1) != 0) {
            return false; // I2C communication failed
        }
        
        return true; // Initialisation successful
    }

    /**
     * Gets readings from all sensors.
     * 
     * @return SensorReadings struct containing all sensor data
     */
    SensorReadings getAllSensorReadings() {
        return {
            getLeftUltrasonicDistance(),
            getRightUltrasonicDistance(),
            getLeftIRDistance(),
            getRightIRDistance()
        };
    }

    /**
     * Gets filtered distance reading from left ultrasonic sensor.
     * 
     * @return Distance in centimetres, -1 if reading fails or is invalid
     */
    float getLeftUltrasonicDistance() {
        return getUltrasonicDistance(leftUltrasonic);
    }

    /**
     * Gets filtered distance reading from right ultrasonic sensor.
     * 
     * @return Distance in centimetres, -1 if reading fails or is invalid
     */
    float getRightUltrasonicDistance() {
        return getUltrasonicDistance(rightUltrasonic);
    }

    /**
     * Gets filtered distance reading from left IR sensor.
     * 
     * @return Distance in centimetres, -1 if reading fails or is invalid
     */
    float getLeftIRDistance() {
        return getIRDistance(0x02);  // Left IR multiplexer command
    }

    /**
     * Gets filtered distance reading from right IR sensor.
     * 
     * @return Distance in centimetres, -1 if reading fails or is invalid
     */
    float getRightIRDistance() {
        return getIRDistance(0x01);  // Right IR multiplexer command
    }

private:
    /**
     * Helper function to get ultrasonic sensor reading.
     * 
     * @param sensor Reference to the ultrasonic sensor
     * @return Filtered distance in centimetres
     */
  float getUltrasonicDistance(mbed::DigitalInOut& sensor) {
    // Trigger pulse
    sensor.output();
    sensor.write(0);
    wait_us(2);
    sensor.write(1);
    wait_us(10);
    sensor.write(0);

    // Echo pulse
    sensor.input();
    timer.reset();

    // Wait for echo start (with timeout)
    while (!sensor.read()) {
      if (timer.elapsed_time().count() > ULTRA_TIMEOUT) {
          return -1; // Timeout, no valid reading
      }
    }

    timer.reset();
    // Wait for echo end (with timeout)
    while (sensor.read()) {
      if (timer.elapsed_time().count() > ULTRA_TIMEOUT) {
          return -1; // Timeout, no valid reading
      }
    }

    uint64_t duration = timer.elapsed_time().count();
    float distance = (duration * SPEED_OF_SOUND) / (2.0 * 1000000.0) * 100;

    if (distance >= ULTRA_MIN_RANGE && distance <= ULTRA_MAX_RANGE) {
      return distance;
    }
    return -1; // Invalid reading
  }


    /**
     * Helper function to get IR sensor reading.
     * 
     * @param mux_cmd Multiplexer command for selecting the sensor
     * @return Filtered distance in centimetres
     */
  float getIRDistance(char mux_cmd) {
    // Select multiplexer bus
    i2c.write(I2C_MUX_ADDR, &mux_cmd, 1);
    wait_us(500);
    
    // Read shift bit
    char shift_cmd = I2C_SHIFT_REG;
    char shift_value;
    i2c.write(I2C_SENSOR_ADDR, &shift_cmd, 1);
    wait_us(500);
    i2c.read(I2C_SENSOR_ADDR, &shift_value, 1);
    int shift = shift_value & 0x07;
    
    // Read distance
    char cmd[2] = {I2C_DISTANCE_REG, 0};
    i2c.write(I2C_SENSOR_ADDR, cmd, 1);
    wait_us(500);
    i2c.read(I2C_SENSOR_ADDR, cmd, 2);

    int distanceRaw = (cmd[0] << 4 | cmd[1] & 0x0F);
    float distance = static_cast<float>(distanceRaw) / (16.0f * (1 << shift));
    
    if (distance >= IR_MIN_RANGE && distance <= IR_MAX_RANGE) {
        return distance;
    }
  
    return -1; // Invalid reading
  }


};



// ===== Encoders Class =====
/**
 * Encoder Class
 * 
 * Manages wheel encoders for precise position and speed tracking of the robot's motors.
 */
class Encoder {
private:
    // Hardware interfaces for encoder inputs
    mbed::InterruptIn rightEncoder;
    mbed::InterruptIn leftEncoder;

    // References to motor direction pins
    mbed::DigitalIn& rightMotorDir;
    mbed::DigitalIn& leftMotorDir;

    // Timing counters for speed calculation
    unsigned long lastRightTime = 0;
    unsigned long lastLeftTime = 0;
    int lastRightCount = 0;
    int lastLeftCount = 0;

public:
    // Encoder (tick) counters for position tracking
    volatile int64_t rightTicks = 0;
    volatile int64_t leftTicks = 0;

    /**
     * Constructor: Initialises encoder hardware and sets up interrupts
     * @param rightDir Reference to right motor direction pin
     * @param leftDir Reference to left motor direction pin
     */
    Encoder(mbed::DigitalIn& rightDir, mbed::DigitalIn& leftDir)
        : rightEncoder(MOTOR_ENCODER_R),
          leftEncoder(MOTOR_ENCODER_L),
          rightMotorDir(rightDir),
          leftMotorDir(leftDir) {
        init();
    }

    /**
     * Initialises interrupt handlers for both encoders
     */
    void init() {
        rightEncoder.rise(mbed::callback(this, &Encoder::countRightTick));
        leftEncoder.rise(mbed::callback(this, &Encoder::countLeftTick));
    }

    /**
     * Interrupt handler for right encoder ticks
     * Increments or decrements the tick count based on motor direction
     */
    void countRightTick() {
        rightTicks += (rightMotorDir.read() == 1) ? 1 : -1;
    }

    /**
     * Interrupt handler for left encoder ticks
     * Increments or decrements the tick count based on motor direction
     */
    void countLeftTick() {
        leftTicks += (leftMotorDir.read() == 0) ? 1 : -1;
    }

    /**
     * Resets all counters and timing variables to zero
     */
    void reset() {
        rightTicks = 0;
        leftTicks = 0;
        lastRightCount = 0;
        lastLeftCount = 0;
        lastRightTime = 0;
        lastLeftTime = 0;
    }
};


// ===== Motors Class =====
/**
 * Motors Class
 * 
 * Manages the control of two DC motors for a differential drive robot.
 * Provides functionality for movement, turning, and speed control,
 * incorporating calibration, and encoder feedback.
 */
class Motors {
private:
  // Hardware interfaces
  mbed::DigitalIn rightEncoderPin;
  mbed::DigitalIn leftEncoderPin;
  mbed::DigitalOut rightMotorDir;
  mbed::DigitalOut leftMotorDir;
  mbed::PwmOut rightMotorPWM;
  mbed::PwmOut leftMotorPWM;

  // Current direction
  char currentDirection;

  // Lookup tables for calibration 
  // SpeedEntry struct represents a single entry in the speed calibration test table
  struct SpeedEntry {
    float pwm;           // PWM duty cycle (0.0 to 1.0)
    float speedLeft;     // Left motor speed in cm/s
    float speedRight;    // Right motor speed in cm/s
    float speedForward;  // Forward speed in cm/s
    float speedBackward; // Backward speed in cm/s

    // Constructor
    SpeedEntry(float p, float sL, float sR, float sF, float sB)
      : pwm(p), speedLeft(sL), speedRight(sR), speedForward(sF), speedBackward(sB) {}
  };


  // Speed calibration table based on empirical measurements
  // Each entry maps a PWM value to corresponding motor speed in a certain direction
  static const int NUM_ENTRIES = 10;
  const SpeedEntry speedTable[NUM_ENTRIES] = {
    {0.1, 0.0, 0.0, 0.0, -0.77},
    {0.2, -7.58, 13.27, 2.61, -2.67},
    {0.3, -15.5, 22.48, 4.5, -4.48},
    {0.4, -23.98, 31.52, 6.29, -6.3},
    {0.5, -32.04, 40.47, 8.12, -8.09},
    {0.6, -41.1, 49.35, 9.89, -9.86},
    {0.7, -49.33, 57.76, 11.61, -11.62},
    {0.8, -58.03, 66.36, 13.68, -13.41},
    {0.9, -66.11, 74.59, 14.96, -15.11},
    {1.0, -74.72, 83.51, 16.73, -16.97}
  };

    // Timing variables for speed calculation
    unsigned long lastRightTime = 0;
    unsigned long lastLeftTime = 0;
    int lastRightCount = 0;
    int lastLeftCount = 0;


public:
    Encoder encoder;
    /**
    * Constructor: Initialises motor hardware interfaces and encoder
    */
    Motors()
  : encoder(rightEncoderPin, leftEncoderPin),  // initalise encoder first
    rightEncoderPin(MOTOR_ENCODER_R),
    leftEncoderPin(MOTOR_ENCODER_L),
    rightMotorDir(MOTOR_DIR_R),
    leftMotorDir(MOTOR_DIR_L),
    rightMotorPWM(MOTOR_PWM_R),
    leftMotorPWM(MOTOR_PWM_L)
    {
    init();

    }

    /**
      * Initialises motor hardware and PWM settings
      */
    void init() {
      rightMotorPWM.period(1.0f / PWM_FREQUENCY);
      leftMotorPWM.period(1.0f / PWM_FREQUENCY);
      stop();
    }

    /**
      * Returns a valid PWM value for the left motor
      */
    float getLeftPWM() {
      return leftMotorPWM.read();
    }

    /**
      * Returns a valid PWM value for the right motor
      */
    float getRightPWM() {
      return rightMotorPWM.read();
    }

    /**
    * Sets valid PWM value  for the left motor
      */
    void setLeftPWM(float pwm) {
        pwm = pwm < 0.0f ? 0.0f : (pwm > 1.0f ? 1.0f : pwm);
        leftMotorPWM.write(pwm);
    }
    /**
    * Sets valid PWM value  for the right motor
    */
    void setRightPWM(float pwm) {
        pwm = pwm < 0.0f ? 0.0f : (pwm > 1.0f ? 1.0f : pwm);
        rightMotorPWM.write(pwm);
    }

    /**
    * Calculates distance traveled by right wheel in centimetres
    * @return Distance in centimetres
    */
    float getRightDistanceCm() {
      return encoder.rightTicks * RIGHT_TICKS_TO_CM;
    }

    /**
    * Calculates distance traveled by left wheel in centimetres
    * @return Distance in centimetres
    */
    float getLeftDistanceCm() {
      return encoder.leftTicks * LEFT_TICKS_TO_CM;
    }

  /**
    * Sets the speed for both motors.
    * @param leftSpeed Desired speed for the left motor (cm/s)
    * @param rightSpeed Desired speed for the right motor (cm/s)
   */
   void setSpeed(float leftSpeed, float rightSpeed) {
    float leftPWM = speedToPWM(leftSpeed, 'L');
    float rightPWM = speedToPWM(rightSpeed, 'R');
    
    // Set PWM values
    setLeftPWM(leftPWM);
    setRightPWM(rightPWM);
  }

    /**
    * Calculates and returns the current speed of right wheel
    * @return Speed in cm/s
    */
    float getRightSpeed() {
      unsigned long currentTime = micros();
      float timeDiff = (currentTime - lastRightTime) / 1000000.0f;
      float distance = (encoder.rightTicks - lastRightCount) * RIGHT_TICKS_TO_CM;

      lastRightTime = currentTime;
      lastRightCount = encoder.rightTicks;

      return distance / timeDiff;
    }

    /**
    * Calculates and returns the current speed of left wheel
    * @return Speed in cm/s
    */
    float getLeftSpeed() {
      unsigned long currentTime = micros();
      float timeDiff = (currentTime - lastLeftTime) / 1000000.0f;
      float distance = (encoder.leftTicks - lastLeftCount) * LEFT_TICKS_TO_CM;

      lastLeftTime = currentTime;
      lastLeftCount = encoder.leftTicks;

      return distance / timeDiff;
    }


  /**
    * Converts target speed to PWM value for specified motor and direction
    * @param speed Target speed in cm/s
    * @param motor Motor selection ('L' for left, 'R' for right)
    * @return Calculated PWM value between MIN_PWM and MAX_PWM
  */
  float speedToPWM(float speed, char motor) {
    if (motor != 'L' && motor != 'R') return 0.0f;
    float absSpeed = std::abs(speed);

    // Determine which speed column to use based on direction and motor
    int speedColumn;
    if (currentDirection == 'F') {
        speedColumn = (motor == 'L') ? 1 : 2; // Left or Right forward
    } else if (currentDirection == 'B') {
        speedColumn = 4; // Backward
    } else {
        return 0.0f; // Invalid direction
    }

    // Find the appropriate speed range in the table
    int lowerIndex = 0;
    for (int i = 0; i < NUM_ENTRIES - 1; i++) {
        if (absSpeed <= std::abs(speedTable[i + 1].speedForward)) {
            lowerIndex = i;
            break;
        }
    }

    // Perform linear interpolation
    float lowerSpeed = std::abs(speedTable[lowerIndex].speedForward);
    float upperSpeed = std::abs(speedTable[lowerIndex + 1].speedForward);
    float lowerPWM = speedTable[lowerIndex].pwm;
    float upperPWM = speedTable[lowerIndex + 1].pwm;

    float t = (absSpeed - lowerSpeed) / (upperSpeed - lowerSpeed);
    float interpolatedPWM = lowerPWM + t * (upperPWM - lowerPWM);

    return (speed >= 0) ? interpolatedPWM : -interpolatedPWM;
}

  /**
    Sets the speed for both motors
    This method converts the desired speeds to PWM values and applies them to the motors.
    It uses lookup tables to determine the appropriate PWM values for the given speeds.
    @param leftSpeed Desired speed for the left motor (in cm/s)
    @param rightSpeed Desired speed for the right motor (in cm/s)
    */
  float PWMtoSpeed(float pwm, char motor) {
    if (motor != 'L' && motor != 'R') return 0.0f;
    float absPWM = std::abs(pwm);

    // Determine which speed column to use based on direction and motor
    int speedColumn;
    if (currentDirection == 'F') {
        speedColumn = (motor == 'L') ? 1 : 2; // Left or Right forward
    } else if (currentDirection == 'B') {
        speedColumn = 4; // Backward
    } else {
        return 0.0f; // Invalid direction
    }

    // Find the appropriate PWM range row in the table
    int lowerIndex = 0;
    for (int i = 0; i < NUM_ENTRIES - 1; i++) {
      if (absPWM <= speedTable[i + 1].pwm) {
          lowerIndex = i;
          break;
      }
    }

    // Perform linear interpolation
    float lowerPWM = speedTable[lowerIndex].pwm;
    float upperPWM = speedTable[lowerIndex + 1].pwm;
    float lowerSpeed = speedTable[lowerIndex].speedForward;
    float upperSpeed = speedTable[lowerIndex + 1].speedForward;

    float t = (absPWM - lowerPWM) / (upperPWM - lowerPWM);
    float interpolatedSpeed = lowerSpeed + t * (upperSpeed - lowerSpeed);

    return (pwm >= 0) ? interpolatedSpeed : -interpolatedSpeed;
  }


  /**
    * Sets the direction of both motors based on desired robot movement.
    * @param direction 'F' (Forward), 'B' (Backward), 'L' (Left Turn), or 'R' (Right Turn)
  */
  void setDirection(char direction) {
    currentDirection = direction;
      switch (direction) {
      case 'F':                  // Forward
        leftMotorDir.write(0);   // Left: 0 is forward
        rightMotorDir.write(1);  // Right: 1 is forward
        break;
      case 'B':                  // Backward
        leftMotorDir.write(1);   // Left: 1 is backward
        rightMotorDir.write(0);  // Right: 0 is backward
        break;
      case 'L':                  // Turn Left
        leftMotorDir.write(1);   // Left: backward
        rightMotorDir.write(1);  // Right: forward
        break;
      case 'R':                  // Turn Right
        leftMotorDir.write(0);   // Left: forward
        rightMotorDir.write(0);  // Right: backward
        break;
      default:
        // Handle invalid input
        break;
    }
  }

  /**
    * Returns the current direction of the motors
    * 
    */
  char getDirection() {
    return currentDirection;
  }

  /**
  * Applies short brake followed by high impedance state
  */
  void brake() {
    // Short brake
    rightMotorDir.write(1);
    leftMotorDir.write(1);
    rightMotorPWM.write(0);
    leftMotorPWM.write(0);

    wait_us(BRAKE_TIME);

    // High impedance state
    rightMotorDir.write(0);
    leftMotorDir.write(0);
    rightMotorPWM.write(0);
    leftMotorPWM.write(0);
  }

  /**
  * Immediate power cutoff
  */
  void stop() {
    // Direct power cut to both motors
    rightMotorPWM.write(0);
    leftMotorPWM.write(0);
  }
};



// ===== PID Controller Class =====
/**
*  PIDController Class
*
*  Implements a Proportional-Integral-Derivative controller for precise control
*  of various robot systems such as motor speed, position, or orientation.
*/
class PIDController {
private:
  float kp, ki, kd;
  float integral, prevError;

public:
  /**
    * Constructor: Initialises PID controller with given gains
    *
    * @param p Proportional gain
    * @param i Integral gain
    * @param d Derivative gain
  */
  PIDController(float p, float i, float d) : kp(p), ki(i), kd(d), integral(0), prevError(0) {}

  /**
  * Calculates the PID output based on the current error and time step
  * 
  * @param error Current error (setpoint - measured value)
  * @param dt Time step since last calculation
  * @return PID output
 */
  float calculate(float error, float dt) {
      integral += error * dt;
      float derivative = (error - prevError) / dt;
      prevError = error;
      return kp * error + ki * integral + kd * derivative;
  }
};


// ===== Particle Class =====
/**
  Particle Class
  Represents a single particle in a particle filter, used for
  localisation and mapping in robotics applications.
*/
class Particle {
public:
  float x;        // X position
  float y;        // Y position
  float theta;    // Orientation
  float weight;   // Particle weight for importance sampling

  /**
    Default constructor: Initialises particle at origin with default weight
  */
  Particle() : x(0), y(0), theta(0), weight(1.0f) {}

  /**
    Constructor: Initialises particle with given position and orientation
    @param x_ X coordinate
    @param y_ Y coordinate
    @param theta_ Orientation in radians
  */
  Particle(float x_, float y_, float theta_) 
      : x(x_), y(y_), theta(theta_), weight(1.0f) {}
  
};


// ===== LowPassFilter Class =====
/**
 * LowPassFilter class
 * 
 * This class implements a simple low-pass filter 
 * 
 * The filter uses an exponential moving average with a configurable alpha value.
 * A smaller alpha results in smoother but slower-responding output, while a
 * larger alpha allows for quicker response to changes but with less smoothing.
 * 
 * Usage:
 * - Initialise with a desired alpha value (0 < alpha <= 1)
 * - Call update() with each new sensor reading
 * - Retrieve the filtered value using getValue()
 */
class LowPassFilter {
private:
    float alpha;
    float filteredValue;

public:
    LowPassFilter(float alpha = 0.1) : alpha(alpha), filteredValue(0) {}

    float update(float newValue) {
        filteredValue = alpha * newValue + (1 - alpha) * filteredValue;
        return filteredValue;
    }
};



// ===== SLAM Class =====
/**
 * SLAM Class
 *
 * This class integrates localiSation, mapping, and navigation functionalities for a mobile robot.
 * 
 * Key components:
 * - Particle filter: Used for localiSation (200 particles)
 * - Occupancy grid: Represents the environment (24x24 grid, 10cm cell size)
 * - PID controllers: Ensure accurate movement and turning
 * 
 * Concurrent threads:
 * 1. localisationThread: Updates pose estimate and particle filter (50ms intervals)
 * 2. mappingThread: Updates occupancy grid based on sensor readings (100ms intervals)
 * 
 * Navigation methods:
 * - moveToPoint(): Moves to specific coordinates
 * - turn(): Rotates to a target angle
 * - moveForward(): Moves a specified distance
 * 
 * Algorithms and models:
 * - Particle filter: Monte Carlo localisation
 * - PID control: For linear and angular motion control
 * - Bresenham's line algorithm: For ray-casting in occupancy grid updates
 * - Gaussian random number generation: For particle dispersion
 * 
 * Data structures:
 * - Occupancy grid: std::vector<float> (1D array representing 2D grid)
 * - Particles: std::array<Particle, 200>
 * 
 * Synchronisation:
 * - std::mutex for thread-safe access to pose and grid data
 */
class SLAM {
private:
    Motors& motors;
    Sensors& sensors;
    std::array<Particle, 200> particles; 
    std::vector<float> occupancyGrid;
    Pose currentPose;
    
    volatile bool poseUpdateInProgress = false;
    std::atomic<bool> gridUpdateInProgress{false};

    Thread localisationThread;
    Thread mappingThread;
    volatile bool running = true;

    LowPassFilter leftUltrasonicFilter;
    LowPassFilter rightUltrasonicFilter;
    LowPassFilter leftIRFilter;
    LowPassFilter rightIRFilter;
    PIDController leftPID;
    PIDController rightPID;

    float lastLeftDistance = 0.0f;
    float lastRightDistance = 0.0f;

    Sensors::SensorReadings getAllSensorReadings() {
    Sensors::SensorReadings rawReadings = sensors.getAllSensorReadings();
    return {
        leftUltrasonicFilter.update(rawReadings.leftUltrasonic),
        rightUltrasonicFilter.update(rawReadings.rightUltrasonic),
        leftIRFilter.update(rawReadings.leftIR),
        rightIRFilter.update(rawReadings.rightIR)
    };
}

public:

    SLAM(Motors& m, Sensors& s) : 
    motors(m), 
    sensors(s),
    leftUltrasonicFilter(0.1f),
    rightUltrasonicFilter(0.1f),
    leftIRFilter(0.1f),
    rightIRFilter(0.1f),
    leftPID(1.0f, 0.1f, 0.05f),  // Adjust these PID values as needed
    rightPID(1.0f, 0.1f, 0.05f)  // Adjust these PID values as needed
    {
        occupancyGrid.resize(GRID_SIZE * GRID_SIZE, 0.5f);
        initialiseParticles();
        
        localisationThread.start(callback(this, &SLAM::localisationThreadFunc));
        mappingThread.start(callback(this, &SLAM::mappingThreadFunc));
    }
    ~SLAM() {
        running = false;
        localisationThread.join();
        mappingThread.join();
    }


    Pose getCurrentPose() {
      while (poseUpdateInProgress) {
          // Busy wait
      }
      poseUpdateInProgress = true;
      Pose currentPoseCopy = currentPose;
      poseUpdateInProgress = false;
      return currentPoseCopy;
    }
    
    bool isOccupied(int x, int y) {
      while (gridUpdateInProgress) {
          // Busy wait
      }
      gridUpdateInProgress = true;
      bool occupied = occupancyGrid[y * GRID_SIZE + x] > OCCUPIED_THRESHOLD;
      gridUpdateInProgress = false;
      return occupied;
    }
    
    bool isFree(int x, int y) {
        while (gridUpdateInProgress.exchange(true)) {
            // Busy-wait
        }
        bool free = occupancyGrid[y * GRID_SIZE + x] < FREE_THRESHOLD;
        gridUpdateInProgress.store(false);
        return free;
    }

    const std::vector<float>& getGrid() const {
    return occupancyGrid;
    }


private:
    void localisationThreadFunc() {
        while (running) {
            updatePoseEstimate();
            updateParticles();
            rtos::ThisThread::sleep_for(50ms);
        }
    }

    void mappingThreadFunc() {
        while (running) {
            updateGrid();
            rtos::ThisThread::sleep_for(100ms);
        }
    }
    
  void initialiseParticles() {
      for (auto& particle : particles) {
          particle.x = currentPose.x + randomGaussian(0, 0.1);
          particle.y = currentPose.y + randomGaussian(0, 0.1);
          particle.theta = currentPose.theta + randomGaussian(0, 0.05);
          particle.weight = 1.0f / particles.size();
      }
  }

  void updatePoseEstimate() {
    float leftDistance = motors.getLeftDistanceCm();
    float rightDistance = motors.getRightDistanceCm();
    float deltaLeft = leftDistance - lastLeftDistance;
    float deltaRight = rightDistance - lastRightDistance;
    
    float deltaDistance = (deltaLeft + deltaRight) / 2.0f;
    float deltaTheta = (deltaRight - deltaLeft) / ROBOT_DIAMETER;
    
    Sensors::SensorReadings readings = sensors.getAllSensorReadings();
    
    // Use sensor readings to refine pose estimate
    float sensorWeight = 0.3; // Adjust based on sensor reliability
    deltaDistance = (1 - sensorWeight) * deltaDistance + 
                    sensorWeight * (readings.leftUltrasonic + readings.rightUltrasonic) / 2;
    
    while (poseUpdateInProgress) {
        // Busy wait
    }
    poseUpdateInProgress = true;
    currentPose.x += deltaDistance * std::cos(currentPose.theta);
    currentPose.y += deltaDistance * std::sin(currentPose.theta);
    currentPose.theta += deltaTheta;
    currentPose.theta = std::atan2(std::sin(currentPose.theta), std::cos(currentPose.theta));
    poseUpdateInProgress = false;
    
    lastLeftDistance = leftDistance;
    lastRightDistance = rightDistance;
  }


    
  void updateParticles() {
      Sensors::SensorReadings readings = sensors.getAllSensorReadings();
      
      for (auto& particle : particles) {
          // Motion update
          particle.x += randomGaussian(0, 0.02);
          particle.y += randomGaussian(0, 0.02);
          particle.theta += randomGaussian(0, 0.01);
          
          // Measurement update
          particle.weight *= calculateLikelihood(particle, readings);
      }
      
      normaliseWeights();
      resampleParticles();
  }
  
  void updateGrid() {
    Pose pose = getCurrentPose();
    Sensors::SensorReadings readings = getAllSensorReadings();
    
    while (gridUpdateInProgress.exchange(true)) {
        // Busy-wait
    }
    updateGridWithReading(pose, readings.leftUltrasonic, calculateSensorAngle(ULTRASONIC_LEFT_X, ULTRASONIC_LEFT_Y), ULTRASONIC_LEFT_X, ULTRASONIC_LEFT_Y);
    updateGridWithReading(pose, readings.rightUltrasonic, calculateSensorAngle(ULTRASONIC_RIGHT_X, ULTRASONIC_RIGHT_Y), ULTRASONIC_RIGHT_X, ULTRASONIC_RIGHT_Y);
    updateGridWithReading(pose, readings.leftIR, calculateSensorAngle(IR_LEFT_X, IR_LEFT_Y), IR_LEFT_X, IR_LEFT_Y);
    updateGridWithReading(pose, readings.rightIR, calculateSensorAngle(IR_RIGHT_X, IR_RIGHT_Y), IR_RIGHT_X, IR_RIGHT_Y);
    gridUpdateInProgress.store(false);
}

  
  void updateGridWithReading(const Pose& pose, float reading, float sensorAngle, float sensorOffsetX, float sensorOffsetY) {
    float sensorX = pose.x + (sensorOffsetX * std::cos(pose.theta) - sensorOffsetY * std::sin(pose.theta)) / 10.0f;
    float sensorY = pose.y + (sensorOffsetX * std::sin(pose.theta) + sensorOffsetY * std::cos(pose.theta)) / 10.0f;
    
    float globalSensorAngle = pose.theta + sensorAngle;
    
    for (float distance = 0; distance <= reading; distance += CELL_SIZE / 2) {
      int x = static_cast<int>((sensorX + distance * std::cos(globalSensorAngle)) / CELL_SIZE);
      int y = static_cast<int>((sensorY + distance * std::sin(globalSensorAngle)) / CELL_SIZE);
      
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) break;
      
      if (distance < reading) {
          occupancyGrid[y * GRID_SIZE + x] = std::max(0.0f, occupancyGrid[y * GRID_SIZE + x] - 0.1f);
      } else {
          occupancyGrid[y * GRID_SIZE + x] = std::min(1.0f, occupancyGrid[y * GRID_SIZE + x] + 0.1f);
      }
    }
  }

  
  float calculateLikelihood(const Particle& particle, const Sensors::SensorReadings& readings) {
      // Simplified likelihood calculation
      float expectedLeft = calculateExpectedReading(particle, -M_PI/4, ULTRASONIC_LEFT_X, ULTRASONIC_LEFT_Y);
      float expectedRight = calculateExpectedReading(particle, M_PI/4, ULTRASONIC_RIGHT_X, ULTRASONIC_RIGHT_Y);
      float error = std::abs(expectedLeft - readings.leftUltrasonic) + std::abs(expectedRight - readings.rightUltrasonic);
      return std::exp(-error * error / (2 * SENSOR_NOISE * SENSOR_NOISE));
  }
  
  float calculateExpectedReading(const Particle& particle, float sensorAngle, float sensorOffsetX, float sensorOffsetY) {
    float sensorX = particle.x + (sensorOffsetX * std::cos(particle.theta) - sensorOffsetY * std::sin(particle.theta)) / 10.0f;
    float sensorY = particle.y + (sensorOffsetX * std::sin(particle.theta) + sensorOffsetY * std::cos(particle.theta)) / 10.0f;
    
    for (float distance = 0; distance < 50.0f; distance += CELL_SIZE) {
        int x = static_cast<int>((sensorX + distance * std::cos(particle.theta + sensorAngle)) / CELL_SIZE);
        int y = static_cast<int>((sensorY + distance * std::sin(particle.theta + sensorAngle)) / CELL_SIZE);
        
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE || isOccupied(x, y)) {
            return distance;
        }
    }
    return 50.0f;
  }
  
  void normaliseWeights() {
    float totalWeight = 0;
    for (const auto& particle : particles) {
        totalWeight += particle.weight;
    }
    for (auto& particle : particles) {
        particle.weight /= totalWeight;
    }
  }
    
    void resampleParticles() {
      std::array<Particle, 200> newParticles;
      std::random_device rd;
      std::mt19937 gen(rd());
      std::uniform_real_distribution<> dis(0, 1);
      
      float step = 1.0f / particles.size();
      float r = dis(gen) * step;
      float c = particles[0].weight;
      int i = 0;
      
      for (size_t m = 0; m < particles.size(); m++) {
          float U = r + m * step;
          while (U > c) {
              i++;
              c += particles[i].weight;
          }
          newParticles[m] = particles[i];
          newParticles[m].weight = 1.0f / particles.size();
      }
      
      particles = std::move(newParticles);
    }
    
    float randomGaussian(float mean, float stddev) {
      static std::random_device rd;
      static std::mt19937 gen(rd());
      std::normal_distribution<> d(mean, stddev);
      return d(gen);
    }

    public:
    void moveToPoint(float targetX, float targetY, float speed) {
      while (!reachedTarget(targetX, targetY)) {
        Pose currentPose = getCurrentPose();
        float dx = targetX - currentPose.x;
        float dy = targetY - currentPose.y;
        float distanceToTarget = std::sqrt(dx*dx + dy*dy);
        float angleToTarget = std::atan2(dy, dx);

        // Adjust orientation
        if (std::abs(angleToTarget - currentPose.theta) > 0.1) {
            turn(angleToTarget - currentPose.theta, TURN_SPEED);
        }

        // Move forward
        moveForward(std::min(distanceToTarget, 10.0f), speed);
        
        ThisThread::sleep_for(50ms);
      }
    }

  void turn(float angle, float angularSpeed) {
    float initialTheta = getCurrentPose().theta;
    float targetAngle = initialTheta + angle;
    float direction = angle >= 0 ? 1.0f : -1.0f;
    
    motors.setDirection(angle >= 0 ? 'R' : 'L');
    
    while (std::abs(targetAngle - getCurrentPose().theta) > 0.01) {
        float currentAngularSpeed = (motors.getRightSpeed() - motors.getLeftSpeed()) / ROBOT_DIAMETER;
        float error = direction * angularSpeed - currentAngularSpeed;
        
        float correction = leftPID.calculate(error, 0.01f);
        
        float leftPWM = std::max(0.1f, std::min(0.5f - correction, 1.0f));
        float rightPWM = std::max(0.1f, std::min(0.5f + correction, 1.0f));
        
        motors.setLeftPWM(leftPWM);
        motors.setRightPWM(rightPWM);
        
        ThisThread::sleep_for(10ms);
    }
    motors.stop();
}



  void moveForward(float distance, float speed) {
    float initialX = getCurrentPose().x;
    float initialY = getCurrentPose().y;
    float targetDistance = std::abs(distance);
    float direction = distance >= 0 ? 1.0f : -1.0f;
    
    motors.setDirection(direction >= 0 ? 'F' : 'B');
    
    while (true) {
        Pose currentPose = getCurrentPose();
        float currentDistance = std::sqrt(std::pow(currentPose.x - initialX, 2) + std::pow(currentPose.y - initialY, 2));
        if (currentDistance >= targetDistance) break;

        float leftSpeed = motors.getLeftSpeed();
        float rightSpeed = motors.getRightSpeed();
        
        float leftError = direction * speed - leftSpeed;
        float rightError = direction * speed - rightSpeed;
        
        float leftPWM = leftPID.calculate(leftError, 0.01f);
        float rightPWM = rightPID.calculate(rightError, 0.01f);
        
        leftPWM = std::max(0.1f, std::min(leftPWM, 1.0f));
        rightPWM = std::max(0.1f, std::min(rightPWM, 1.0f));
        
        motors.setLeftPWM(leftPWM);
        motors.setRightPWM(rightPWM);
        
        ThisThread::sleep_for(10ms);
    }
    motors.stop();
}


private:
    void setMotorSpeeds(float leftSpeed, float rightSpeed) {
        motors.setSpeed(leftSpeed, rightSpeed);
    }

    bool reachedTarget(float targetX, float targetY) {
        Pose currentPose = getCurrentPose();
        float dx = targetX - currentPose.x;
        float dy = targetY - currentPose.y;
        return std::sqrt(dx*dx + dy*dy) < 0.5; // 0.5 cm threshold
    }

    void setDifferentialSpeed(float targetLeftSpeed, float targetRightSpeed) {
    float leftPWM = 0, rightPWM = 0;
    const float maxPWM = 1.0f;  // Assuming normalized PWM values
    
    while (true) {
        Sensors::SensorReadings readings = getAllSensorReadings();
        float leftSpeed = motors.getLeftSpeed();
        float rightSpeed = motors.getRightSpeed();
        
        // Combine encoder and sensor data
        float leftSpeedAdjusted = 0.7f * leftSpeed + 0.3f * readings.leftIR;
        float rightSpeedAdjusted = 0.7f * rightSpeed + 0.3f * readings.rightIR;
        
        float leftError = targetLeftSpeed - leftSpeedAdjusted;
        float rightError = targetRightSpeed - rightSpeedAdjusted;
        
        leftPWM += leftPID.calculate(leftError, 0.01f);
        rightPWM += rightPID.calculate(rightError, 0.01f);
        
        leftPWM = std::max(0.0f, std::min(leftPWM, maxPWM));
        rightPWM = std::max(0.0f, std::min(rightPWM, maxPWM));
        
        motors.setLeftPWM(leftPWM);
        motors.setRightPWM(rightPWM);
        
        if (std::abs(leftError) < 0.1f && std::abs(rightError) < 0.1f) {
            break;
        }
        
        ThisThread::sleep_for(10ms);
    }
}


  float calculateSensorAngle(float x, float y) {
    return std::atan2(y, x);
}
};


/* PathPlanner Class
 *
 * Handles path planning for the Orbit-360 robot.
 * Uses A* algorithm to find optimal paths between two points
 * based on the current map of the environment.
 */
 
class PathPlanner {
private:
  SLAM& slam;
  static const int MAX_NODES = 1000; 
  static const int ROBOT_RADIUS_IN_CELLS = ROBOT_DIAMETER / (2 * CELL_SIZE);


  int nodeCount = 0;

  // Node structure for A* pathfinding algorithm
  struct Node {
    int x, y;           // Grid coordinates of the node
    float g;            // Cost from start to this node
    float h;            // Heuristic estimate from this node to goal
    float f;            // Total estimated cost (f = g + h)
    Node* parent;       // Pointer to parent node in the path

    // Constructor for Node
    // x_, y_: Node coordinates
    // g_: Cost from start (default 0)
    // h_: Heuristic cost to goal (default 0)
    // parent_: Pointer to parent node (default nullptr)
    Node() : x(0), y(0), g(0), h(0), f(0), parent(nullptr) {}
    Node(int x_, int y_, float g_ = 0, float h_ = 0, Node* parent_ = nullptr)
        : x(x_), y(y_), g(g_), h(h_), f(g_ + h_), parent(parent_) {}
  };

    Node nodePool[MAX_NODES];
  // Comparison structure for Node pointers
  // Used in priority queue to order nodes by their f-cost
  struct CompareNode {
    // Comparison operator
    // Returns true if node a has a higher f-cost than node b
    // This creates a min-heap based on f-cost
    bool operator()(const Node* a, const Node* b) const {
        return a->f > b->f;
    }
  };

public:
  PathPlanner(SLAM& slam_) : slam(slam_) {
    for (int i = 0; i < MAX_NODES; ++i) {
        nodePool[i] = Node();
    }
  }


    /**
  * Finds a path from start to goal using A* algorithm
  * @param startX Starting X-coordinate
  * @param startY Starting Y-coordinate
  * @param goalX Goal X-coordinate
  * @param goalY Goal Y-coordinate
  * @return Vector of coordinate pairs representing the path
  */
  std::vector<std::pair<int, int>> findPath(int startX, int startY, int goalX, int goalY) {
    std::priority_queue<Node*, std::vector<Node*>, CompareNode> openList;
    std::vector<std::vector<bool>> closedList(GRID_SIZE, std::vector<bool>(GRID_SIZE, false));
    
    Node* startNode = new Node(startX, startY);
    startNode->h = heuristic(startX, startY, goalX, goalY);
    openList.push(startNode);

    while (!openList.empty()) {
      Node* current = openList.top();
      openList.pop();

      if (current->x == goalX && current->y == goalY) {
          return reconstructPath(current);
      }

      closedList[current->y][current->x] = true;

      for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            if (dx == 0 && dy == 0) continue;

            int newX = current->x + dx;
            int newY = current->y + dy;

            if (!isValidNode(newX, newY, closedList)) continue;

            float newG = current->g + ((dx == 0 || dy == 0) ? 1.0f : 1.414f);
            float newH = heuristic(newX, newY, goalX, goalY);
            
            Node* neighbor = new Node(newX, newY, newG, newH, current);
            openList.push(neighbor);
        }
      }
    }

        return {}; // No path found
  }

private:

  // to do comments
  bool isValidNode(int x, int y, const std::vector<std::vector<bool>>& closedList) {
      if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
      if (closedList[y][x]) return false;

    for (int dx = -ROBOT_RADIUS_IN_CELLS; dx <= ROBOT_RADIUS_IN_CELLS; dx++) {
      for (int dy = -ROBOT_RADIUS_IN_CELLS; dy <= ROBOT_RADIUS_IN_CELLS; dy++) {
        int checkX = x + dx;
        int checkY = y + dy;
        if (checkX >= 0 && checkX < GRID_SIZE && checkY >= 0 && checkY < GRID_SIZE) {
          if (slam.isOccupied(checkX, checkY)) {
              return false;
          }
        }
      }
    }
      return true;
    }


    /**
  * Calculates heuristic distance between two points
  * @param x1 Starting X-coordinate
  * @param y1 Starting Y-coordinate
  * @param x2 Ending X-coordinate
  * @param y2 Ending Y-coordinate
  * @return Euclidean distance between the points
  */
  float heuristic(int x1, int y1, int x2, int y2) {
        return std::sqrt(std::pow(x2 - x1, 2) + std::pow(y2 - y1, 2));
    }

  /**
  * Reconstructs the path from goal to start
  * @param goalNode Pointer to the goal node
  * @return Vector of coordinate pairs representing the path
 */
  std::vector<std::pair<int, int>> reconstructPath(Node* goalNode) {
        std::vector<std::pair<int, int>> path;
        Node* current = goalNode;
        while (current != nullptr) {
            path.emplace_back(current->x, current->y);
            current = current->parent;
        }
        std::reverse(path.begin(), path.end());
        return path;
    }
};



// ===== Robot Class =====
/* Robot Class
 *
 * Main control class for the Orbit-360 robot which manages 
 * the overall behaviour of the robot, including exploration,
 * mapping, path planning, and navigation.
 */
class Robot {
private:
  Motors motors;
  Sensors sensors;
  SLAM slam;
  PathPlanner pathPlanner;
  Adafruit_NeoPixel led;
  
  Pose startPosition;
  
  int stuckAttempts = 0;
  Pose lastPosition;
  unsigned long lastMoveTime = 0;

  /**
  Enum representing different states of the robot during operation.
  */
  enum class RobotState {
      Exploring,
      ObstacleDetected,
      AvoidingObstacle,
      Stuck,
      Planning,
      MappingComplete,
      ReturningToStart,
      Finished
  };

public:
  /**
  * Constructor: Initialises all components of the robot.
  */
  Robot() : 
        motors(), 
        sensors(), 
        led(NUM_PIXELS, LED, NEO_GRBW + NEO_KHZ800),
        slam(motors, sensors), 
        pathPlanner(slam)
    {
        motors.encoder.reset();
        startPosition = slam.getCurrentPose();
        if (sensors.begin()) {
            Serial.println("Sensors initialised successfully");
        } else {
            Serial.println("Sensor initialisation failed");
        }
        led.begin();
        led.fill(led.Color(255, 255, 255)); // set to white
        led.show();
    }
  /**
  * Main exploration function. Manages the robot's behavior while exploring the maze.
  */
  void exploreMaze() {
    wait_us(1000000); // Wait 1 second
    motors.encoder.reset();
    updateLED(RobotState:: Exploring);
    
    lastMoveTime = millis();
    Serial.println("Starting maze exploration");

    Serial.print("isMazeExplored() returns: ");
    Serial.println(isMazeExplored());

    while (!isMazeExplored()) {
      
      Serial.print("Current state: ");
      if (isStuck()) {
        Serial.println("Stuck");
        updateLED(RobotState::Stuck);
        handleStuckSituation();
      } else if (isObstacleAhead()) {
        Serial.println("Obstacle detected");
        updateLED(RobotState::ObstacleDetected);
        updateLED(RobotState::AvoidingObstacle);
        turnToFreeDirection();
      } else {
        Serial.println("Exploring");
        updateLED(RobotState::Exploring);
        auto frontiers = getFrontiers();
        if (!frontiers.empty()) {
          Serial.print("Moving to frontier: (");
          auto nearestFrontier = getNearestFrontier(frontiers);
          moveToFrontier(nearestFrontier);
          Serial.print(nearestFrontier.first);
          Serial.print(", ");
          Serial.print(nearestFrontier.second);
          Serial.println(")");

        } else {
          Serial.println("Moving forward");
          moveForward();
        }
      }
    Serial.print("Left motor PWM: ");
    Serial.print(motors.getLeftPWM());
    Serial.print(", Right motor PWM: ");
    Serial.println(motors.getRightPWM());

      ThisThread::sleep_for(100ms);
    }

    Serial.println("Mapping Complete");
    updateLED(RobotState::MappingComplete);
    ThisThread::sleep_for(5000ms);
    Serial.println("Returning to Start");
    returnToStart();
    Serial.println("Finished");
    updateLED(RobotState::Finished);
  }

private:
  /**
  * Checks if the maze exploration is complete based on the exploration threshold.
  * @return true if maze is sufficiently explored, false otherwise
  */
  bool isMazeExplored() {
    Serial.println("Checking if maze is explored");
    const auto& grid = slam.getGrid();
    int exploredCells = 0;
    for (const auto& cell : grid) {
        if (cell < FREE_THRESHOLD || cell > OCCUPIED_THRESHOLD) {
            exploredCells++;
        }
    }
    
    return static_cast<float>(exploredCells) / grid.size() > EXPLORATION_THRESHOLD;
  }

  /**
  * Detects if there's an obstacle directly in front of the robot.
  * @return true if obstacle detected, false otherwise
  */
   bool isObstacleAhead() {
        Sensors::SensorReadings readings = sensors.getAllSensorReadings();
        return readings.leftUltrasonic < ULTRA_SAFETY_MARGIN || readings.rightUltrasonic < ULTRA_SAFETY_MARGIN;
    }

  /**
  * Turns the robot to the direction with more free space.
  */
  void turnToFreeDirection() {
        Sensors::SensorReadings readings = sensors.getAllSensorReadings();
        
        float maxReading = std::max({readings.leftUltrasonic, 
                                     readings.rightUltrasonic, 
                                     readings.leftIR, 
                                     readings.rightIR});
        
        if (maxReading == readings.leftUltrasonic) {
            slam.turn(slam.getCurrentPose().theta - M_PI / 4, TURN_SPEED);
        } else if (maxReading == readings.rightUltrasonic) {
            slam.turn(slam.getCurrentPose().theta + M_PI / 4, TURN_SPEED);
        } else if (maxReading == readings.leftIR) {
            slam.turn(slam.getCurrentPose().theta - M_PI / 2, TURN_SPEED);
        } else {
            slam.turn(slam.getCurrentPose().theta + M_PI / 2, TURN_SPEED);
        }
    }

  /**
  * Moves the robot forward by a small increment.
  */
  void moveForward() {
        Pose currentPose = slam.getCurrentPose();
        float targetX = currentPose.x + EXPLORATION_SPEED * cos(currentPose.theta);
        float targetY = currentPose.y + EXPLORATION_SPEED * sin(currentPose.theta);
        slam.moveToPoint(targetX, targetY, EXPLORATION_SPEED);
    }

  /**
    * Moves the robot to a specified frontier cell.
    * @param frontier Coordinates of the frontier cell to move to
  */
  void moveToFrontier(const std::pair<int, int>& frontier) {
        float targetX = (frontier.first + 0.5f) * CELL_SIZE;
        float targetY = (frontier.second + 0.5f) * CELL_SIZE;
        slam.moveToPoint(targetX, targetY, EXPLORATION_SPEED);
    }
    
  /**
    * Plans and executes a path back to the starting position.
  */
void returnToStart() {
        motors.encoder.reset();
        updateLED(RobotState::Planning);

        Pose currentPose = slam.getCurrentPose();
        int startX = static_cast<int>(startPosition.x / CELL_SIZE);
        int startY = static_cast<int>(startPosition.y / CELL_SIZE);
        int currentX = static_cast<int>(currentPose.x / CELL_SIZE);
        int currentY = static_cast<int>(currentPose.y / CELL_SIZE);

        std::vector<std::pair<int, int>> path = pathPlanner.findPath(currentX, currentY, startX, startY);

        for (const auto& point : path) {
            float targetX = point.first * CELL_SIZE;
            float targetY = point.second * CELL_SIZE;
            slam.moveToPoint(targetX, targetY, RETURN_SPEED);
            ThisThread::sleep_for(100ms);
        }
        
        motors.stop();
    }

  /**
    * Identifies frontier cells in the current map.
    * @return Vector of frontier cell coordinates
 */
std::vector<std::pair<int, int>> getFrontiers() {
        std::vector<std::pair<int, int>> frontiers;
        const auto& grid = slam.getGrid();
        for (int y = 0; y < GRID_SIZE; y++) {
            for (int x = 0; x < GRID_SIZE; x++) {
                if (isFrontierCell(x, y, grid)) {
                    frontiers.emplace_back(x, y);
                }
            }
        }
        return frontiers;
    }

  /**
  * Determines if a given cell is a frontier cell.
  * @param x X-coordinate of the cell
  * @param y Y-coordinate of the cell
  * @param grid Reference to the occupancy grid
  * @return true if the cell is a frontier, false otherwise
 */
  bool isFrontierCell(int x, int y, const std::vector<float>& grid) {
        if (slam.isFree(x, y)) {
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx, ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        if (grid[ny * GRID_SIZE + nx] == 0.5f) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

  /**
  * Finds the nearest frontier from the current position.
  * @param frontiers Vector of frontier cell coordinates
  * @return Coordinates of the nearest frontier
 */
  std::pair<int, int> getNearestFrontier(const std::vector<std::pair<int, int>>& frontiers) {
        Pose currentPose = slam.getCurrentPose();
        int currentX = static_cast<int>(currentPose.x / CELL_SIZE);
        int currentY = static_cast<int>(currentPose.y / CELL_SIZE);

        std::pair<int, int> nearest = frontiers[0];
        float minDist = std::numeric_limits<float>::max();

        for (const auto& frontier : frontiers) {
            float dist = std::hypot(frontier.first - currentX, frontier.second - currentY);
            if (dist < minDist) {
                minDist = dist;
                nearest = frontier;
            }
        }
        return nearest;
    }
    
  /**
    * Checks if the robot is stuck (not moving for a certain time).
    * @return true if the robot is stuck, false otherwise
  */
  bool isStuck() {
        Pose currentPose = slam.getCurrentPose();
        float distanceMoved = std::hypot(currentPose.x - lastPosition.x, currentPose.y - lastPosition.y);
        unsigned long currentTime = millis();
        
        if (distanceMoved < STUCK_DISTANCE_THRESHOLD && 
            (currentTime - lastMoveTime) > STUCK_TIME_THRESHOLD) {
            return true;
        }
        
        lastPosition = currentPose;
        lastMoveTime = currentTime;
        return false;
    }

  /**
  * Handles the situation when the robot is stuck.
  */
  void handleStuckSituation() {
        updateLED(RobotState::ObstacleDetected);
        
        ThisThread::sleep_for(500ms);
        if (!isObstacleAhead()) return;


        updateLED(RobotState::AvoidingObstacle);
        float minDistance = std::numeric_limits<float>::max();
        float bestAngle = 0;
        // Perform 360 scan
        for (int angle = 0; angle < 360; angle += 15) {
            slam.turn(angle * M_PI / 180, TURN_SPEED);
            Sensors::SensorReadings readings = sensors.getAllSensorReadings();
            float maxSensorReading = std::max({readings.leftUltrasonic, 
                                               readings.rightUltrasonic, 
                                               readings.leftIR, 
                                               readings.rightIR});
            if (maxSensorReading < minDistance) {
                minDistance = maxSensorReading;
                bestAngle = angle;
            }
        }

        slam.turn(bestAngle * M_PI / 180, TURN_SPEED);

        if (isObstacleAhead()) {
            for (int i = 0; i < 24; i++) {
                slam.turn(15 * M_PI / 180, TURN_SPEED);
                if (!isObstacleAhead()) break;
            }
        }

        if (++stuckAttempts >= MAX_STUCK_ATTEMPTS) {
            backtrack();
            stuckAttempts = 0;
        }
    }

 /**
  * Attempts to backtrack when the robot is persistently stuck.
 */
  void backtrack() {
        updateLED(RobotState::Planning);
        Pose currentPose = slam.getCurrentPose();
        std::vector<std::pair<int, int>> path = pathPlanner.findPath(
            static_cast<int>(currentPose.x / CELL_SIZE),
            static_cast<int>(currentPose.y / CELL_SIZE),
            static_cast<int>(startPosition.x / CELL_SIZE),
            static_cast<int>(startPosition.y / CELL_SIZE)
        );

        if (!path.empty()) {
            size_t midpoint = path.size() / 2;
            float targetX = path[midpoint].first * CELL_SIZE;
            float targetY = path[midpoint].second * CELL_SIZE;
            slam.moveToPoint(targetX, targetY, RETURN_SPEED);
        }
    }

  /**
  * Updates the LED colour based on the current robot state.
  * @param state Current state of the robot
 */
  void updateLED(RobotState state) {
    switch (state) {
      case RobotState::Exploring:
        led.fill(led.Color(0, 255, 0)); // Green
        led.show();
       
        break;
      case RobotState::ObstacleDetected:
        led.fill(led.Color(255, 0, 0)); // Red
        break;
      case RobotState::AvoidingObstacle:
        led.fill(led.Color(255, 165, 0)); // Amber
        break;
      case RobotState::Stuck:
        flashRed(300);
        return; // Flashing red
      case RobotState::Planning:
        led.fill(led.Color(0, 0, 255)); // Blue
        break;
      case RobotState::MappingComplete:
        setRainbowColors();
        return; // Rainbow
      case RobotState::ReturningToStart:
        flashGreen(300);
        return; // Flashing green
      case RobotState::Finished:
        rainbowCycle(50);
        return; // Flashing rainbow effect  
    }
      led.show();
      ThisThread::sleep_for(3000ms); // Keep led on for for 3 seconds
      led.fill(led.Color(0, 0, 0)); // Turn off LED
      led.show();
  }

  /**
  * Sets the LED to display rainbow colours.
  */
  void setRainbowColors() {
    uint32_t colors[] = {
      led.Color(255, 0, 0),     // Red
      led.Color(255, 165, 0),   // Orange
      led.Color(255, 255, 0),   // Yellow
      led.Color(0, 255, 0),     // Green
      led.Color(0, 0, 255),     // Blue
      led.Color(128, 0, 128),   // Purple
      led.Color(255, 0, 255)    // Magenta
    };

    for (int i = 0; i < NUM_PIXELS; i++) {
        led.setPixelColor(i, colors[i % 7]);
    }
    led.show();
  }

  /**
  * Cycles through rainbow colours on the LED.
  * @param wait Delay between colours changes in milliseconds
  */
  void rainbowCycle(uint8_t wait) {
    for(int j=0; j<256*5; j++) { // 5 cycles of all colours on wheel
      for(int i=0; i< led.numPixels(); i++) {
          led.setPixelColor(i, Wheel(((i * 256 / led.numPixels()) + j) & 255));
      }
      led.show();
      delay(wait);
    }
  }

  /**
  * Flashes the LED green.
  * @param delayMs Delay between flashes in milliseconds
 */
  void flashGreen(int delayMs) {
    led.fill(led.Color(0, 255, 0));
    led.show();
    delay(delayMs);
    led.fill(led.Color(0, 0, 0));
    led.show();
    delay(delayMs);
  }

    /**
  * Flashes the LED red.
  * @param delayMs Delay between flashes in milliseconds
  */
  void flashRed(int delayMs, int flashes = 5) {
    for (int i = 0; i < flashes; i++) {
      led.fill(led.Color(255, 0, 0));
      led.show();
      delay(delayMs);
      led.fill(led.Color(0, 0, 0));
      led.show();
      delay(delayMs);
    }
  }


    /**
  * Generates a colour for the LED based on wheel position.
  * @param WheelPos Position on the colour wheel (0-255)
  * @return 32-bit colour value
  */
  uint32_t Wheel(byte WheelPos) {
    WheelPos = 255 - WheelPos;
    if(WheelPos < 85) {
      return led.Color(255 - WheelPos * 3, 0, WheelPos * 3);
    }
    if(WheelPos < 170) {
        WheelPos -= 85;
      return led.Color(0, WheelPos * 3, 255 - WheelPos * 3);
    }
    WheelPos -= 170;
    return led.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  }
};





/**
 * Arduino setup function
 */

void setup() {
  Serial.begin(115200);
  delay(3000);  // Wait for Serial connection to establish
}

void loop() {
  Serial.println("Creating Robot object...");
    Robot orbit360;
  Serial.println("Starting maze exploration...");
  orbit360.exploreMaze();
  
  while(1) {
    ThisThread::sleep_for(1000ms);
  }
}
